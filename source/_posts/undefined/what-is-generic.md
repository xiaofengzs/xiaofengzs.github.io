---
title: 从本质上理解泛型
catalog: true
date: 2022-10-05 17:56:46
subtitle:
header-img:
tags: generic 泛型
categories: 编程思想
---

## 什么是泛型

泛型是程序语言设计的一种风格和范式，或者是一种编程范式。泛型允许程序员在强类型程序设计中编写代码时使用某几种类型或者一些以后才指定的类型，在实例化时作为参数指明这些类型。

## 泛型是为了解决什么问题

泛型是为了写出更为通用、更具可重用性的代码或模块。从 C 语言最简单的交换两个变量的 swap 函数说起，参看下面的代码：

```c
void swap(int* x, int* y)
{
  int tmp = *x;
  *x = *y;
  *y = tmp;
}
```

这个函数使用指针交换实际变量的值。然而，这个函数最大的问题就是它只能给 int 值用，这个世界上还有很多类型包括 double、float，这就是静态语言最糟糕的一个问题。想要给其他类型编写交换值的函数，我们需要为其他类型编写同样逻辑的函数，只是类型不一样。

想要避免重复的编写逻辑一样的函数，我们需要需要做到抽象，对于这个C语言函数来讲，就是抽象类型，也就是泛型编程。

## C语言中的泛型

使用void*实现了泛型版本的swap函数。

```c
void swap(void* x, void* y, size_t size)
{
     char tmp[size];
     memcpy(tmp, y, size);
     memcpy(y, x, size);
     memcpy(x, tmp, size);
}
```

这个实现方式有三个重点：

- **函数接口中增加了一个size参数**。为什么要这么干呢？因为，用了 void* 后，类型被“抽象”掉了，编译器不能通过类型得到类型的尺寸了，所以，需要我们手动地加上一个类型长度的标识。
- **函数的实现中使用了memcpy()函数**。为什么要这样干呢？还是因为类型被“抽象”掉了，所以不能用赋值表达式了，很有可能传进来的参数类型还是一个结构体，因此，为了要交换这些复杂类型的值，我们只能使用内存复制的方法了。
- **函数的实现中使用了一个temp[size]数组**。这就是交换数据时需要用的 buffer，用 buffer 来做临时的空间存储。

除了使用 void* 来做泛型，在 C 语言中，还可以用宏定义来做泛型，如下所示：

```c
#define swap(x, y, size) {\
  char temp[size]; \
  memcpy(temp, &y, size); \
  memcpy(&y,   &x, size); \
  memcpy(&x, temp, size); \
}
```

但用宏带来的问题就是编译器做字符串替换，因为宏是做字符串替换，所以会导致代码膨胀，导致编译出的执行文件比较大。不过对于 swap 这个简单的函数来说，用void*和宏替换来说都可以达到泛型。

但是，如果我们不是 swap，而是 min() 或 max() 函数，那么宏替换的问题就会暴露得更多一些。

比如，对于下面的这个宏：

```c
#define min(x, y) （(x)>(y) ? (y) : (x)）
```

其中一个最大的问题，就是有可能会有重复执行的问题。如：

- min(i++, j++) 对于这个案例来说，我们本意是比较完后，对变量做累加，但是，因为宏替换的缘故，这会导致变量i或j被累加两次。
- min(foo(), bar()) 对于这个示例来说，我们本意是比较 foo() 和 bar() 函数的返回值，然而，经过宏替换后，foo() 或 bar() 会被调用两次，这会带来很多问题。

另外，无论是用哪种方式，这种“泛型”是不是太宽松了一些，完全不做类型检查，就是在内存上对拷，直接操作内存的这种方式比较危险，而且就像一个定时炸弹一样，不知道什么时候，在什么条件下就爆炸了。

从上面的两个例子，我们可以发现，无论哪种方式，接口都变得复杂了——加入了size，因为如果不加入size的话，那么我们的函数内部就需要自己检查size。然而，void* 这种地址的方式是没法得到size的。

而宏定义的那种方式，虽然不会把类型给隐藏掉，可以使用像 sizeof(x) 这样的方式得到 size。但是如果类型是 char*，那么，使用sizeof方式只能提到指针类型的size，而不是值的size。另外，对于不同的类型，比如说double和int，那应该用谁的size呢？是不是先转一下型呢？这些都是问题。

于是，这种泛型，让我们根本没有办法检查传入参数的size，导致我们只能增加接口复杂度，加入一个size参数，然后把这个问题抛给调用者了。

## Java中的泛型

Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。

#### Java中的泛型是如何实现的

Java通过类型参数来实现泛型。将类型进行抽象，将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式(可以称之为类型形参), 然后在使用/调用时传入具体的类型(类型实参)。这样在编译时会确定具体的类型

使用Java编写一个swap函数，代码如下：

```java
public static <T> void swap (T a, T b) {
    T c;
    c = a;
    a = b;
    b = c;
}
// 使用如下
swap("A", "b");
swap(1, 2);
```

在这里使用了Java中的泛型函数，定义了一个类型参数`T`, 在使用函数时，传入两个`String`类型的参数，在使用时确定了这个函数的类型参数是`String`。

理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作，算法只关心一个标准的实现。

在这里我们我们使用了类型的泛型，使得这个算法不用关心具体类型。

## 类型系统和泛型的本质

泛式是对类型的抽象，我们使用类型参数代替具体类型，在编译时使用具体类型替换类型参数。

### 什么是类型系统

在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，以及如何操作这些类型，还有这些类型如何互相作用。类型可以确认一个值或者一组值，具有特定的意义和目的。

一般来说，编程语言会有两种类型，一种是内建类型，如 int、float 和 char 等，一种是抽象类型，如 struct、class 和 function 等。抽象类型在程序运行中，可能不表示为值。类型系统在各种语言之间有非常大的不同，也许，最主要的差异存在于编译时期的语法，以及运行时期的操作实现方式。

类型系统可以提供如下功能：

- 程序语言的安全性。使用类型可以让编译器侦测一些代码的错误，强类型语言提供更多的安全性，但是并不能保证绝对的安全。
- 利于编译器的优化。 静态类型语言的类型声明，可以让编译器明确地知道程序员的意图。因此，编译器就可以利用这一信息做很多代码优化工作。
- 代码的可读性。有类型的编程语言，可以让代码更易读和更易维护，代码的语义也更清楚，代码模块的接口（如函数）也更丰富和清楚。
- 抽象化。类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。

但是，正如前面说的，类型系统带来的问题是我们作用于不同类型的代码，虽然长的非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要设计比较底层的玩法。

这是在C语言中出现的问题，C语言是一个提供了精细化操作底层的能力，所以实现起泛型来，就会比较繁琐。但是在Java中，对泛型的支持比较好，能够让程序员轻松的实现泛型，更多的关注业务代码，但是对底层的操作支持没有C语言强大。

### 泛型的本质

要了解泛型的本质，就需要了解类型的本质

- 类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配策略。
- 不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。

而泛型是对类型的抽象，所以泛型的本质是屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型。
